{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WarpMQTT2Api API Documentation","text":""},{"location":"#warp.mqtt_client","title":"<code>mqtt_client</code>","text":"<p>Created on 2025-05-09</p> <p>@author: wf</p>"},{"location":"#warp.mqtt_client.MqttClient","title":"<code>MqttClient</code>","text":"<p>MQTT client</p> Source code in <code>warp/mqtt_client.py</code> <pre><code>class MqttClient:\n    \"\"\"MQTT client\"\"\"\n\n    def __init__(self, mqtt_config: MqttConfig, callback):\n        \"\"\"Initialize with configurations\"\"\"\n        self.mqtt_config = mqtt_config\n        self.client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self.callback = callback\n\n    def on_connect(self, client, userdata, flags, rc, properties=None):\n        \"\"\"Connection callback\"\"\"\n        if userdata or flags or properties:\n            pass\n\n        if rc == 0:\n            logger.info(f\"Connected to MQTT broker at {self.mqtt_config.mqtt_broker}\")\n            client.subscribe(self.mqtt_config.mqtt_topic)\n            logger.info(f\"Subscribed to {self.mqtt_config.mqtt_topic}\")\n        else:\n            logger.error(f\"Failed to connect, return code {rc}\")\n\n    def on_message(self, client, userdata, msg):\n        \"\"\"Message callback\"\"\"\n        if client or userdata:\n            pass\n        if isinstance(msg, mqtt.MQTTMessage):\n            logger.debug(f\"Message received: {msg.topic}\")\n            self.callback(msg)\n\n    def run(self):\n        \"\"\"Run the client loop\"\"\"\n        # Set up auth if needed\n        if self.mqtt_config.mqtt_username and self.mqtt_config.mqtt_password:\n            self.client.username_pw_set(\n                self.mqtt_config.mqtt_username, self.mqtt_config.mqtt_password\n            )\n\n        # Connect to broker\n        try:\n            self.client.connect(\n                self.mqtt_config.mqtt_broker, self.mqtt_config.mqtt_port\n            )\n        except Exception as e:\n            logger.error(f\"Connection failed: {e}\")\n            return False\n\n        # Start loop\n        try:\n            logger.info(\"Starting MQTT loop\")\n            self.client.loop_forever()\n        except KeyboardInterrupt:\n            logger.info(\"Stopping client\")\n        except Exception as e:\n            logger.error(f\"Error in loop: {e}\")\n        finally:\n            self.client.disconnect()\n\n        return True\n</code></pre>"},{"location":"#warp.mqtt_client.MqttClient.__init__","title":"<code>__init__(mqtt_config, callback)</code>","text":"<p>Initialize with configurations</p> Source code in <code>warp/mqtt_client.py</code> <pre><code>def __init__(self, mqtt_config: MqttConfig, callback):\n    \"\"\"Initialize with configurations\"\"\"\n    self.mqtt_config = mqtt_config\n    self.client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)\n    self.client.on_connect = self.on_connect\n    self.client.on_message = self.on_message\n    self.callback = callback\n</code></pre>"},{"location":"#warp.mqtt_client.MqttClient.on_connect","title":"<code>on_connect(client, userdata, flags, rc, properties=None)</code>","text":"<p>Connection callback</p> Source code in <code>warp/mqtt_client.py</code> <pre><code>def on_connect(self, client, userdata, flags, rc, properties=None):\n    \"\"\"Connection callback\"\"\"\n    if userdata or flags or properties:\n        pass\n\n    if rc == 0:\n        logger.info(f\"Connected to MQTT broker at {self.mqtt_config.mqtt_broker}\")\n        client.subscribe(self.mqtt_config.mqtt_topic)\n        logger.info(f\"Subscribed to {self.mqtt_config.mqtt_topic}\")\n    else:\n        logger.error(f\"Failed to connect, return code {rc}\")\n</code></pre>"},{"location":"#warp.mqtt_client.MqttClient.on_message","title":"<code>on_message(client, userdata, msg)</code>","text":"<p>Message callback</p> Source code in <code>warp/mqtt_client.py</code> <pre><code>def on_message(self, client, userdata, msg):\n    \"\"\"Message callback\"\"\"\n    if client or userdata:\n        pass\n    if isinstance(msg, mqtt.MQTTMessage):\n        logger.debug(f\"Message received: {msg.topic}\")\n        self.callback(msg)\n</code></pre>"},{"location":"#warp.mqtt_client.MqttClient.run","title":"<code>run()</code>","text":"<p>Run the client loop</p> Source code in <code>warp/mqtt_client.py</code> <pre><code>def run(self):\n    \"\"\"Run the client loop\"\"\"\n    # Set up auth if needed\n    if self.mqtt_config.mqtt_username and self.mqtt_config.mqtt_password:\n        self.client.username_pw_set(\n            self.mqtt_config.mqtt_username, self.mqtt_config.mqtt_password\n        )\n\n    # Connect to broker\n    try:\n        self.client.connect(\n            self.mqtt_config.mqtt_broker, self.mqtt_config.mqtt_port\n        )\n    except Exception as e:\n        logger.error(f\"Connection failed: {e}\")\n        return False\n\n    # Start loop\n    try:\n        logger.info(\"Starting MQTT loop\")\n        self.client.loop_forever()\n    except KeyboardInterrupt:\n        logger.info(\"Stopping client\")\n    except Exception as e:\n        logger.error(f\"Error in loop: {e}\")\n    finally:\n        self.client.disconnect()\n\n    return True\n</code></pre>"},{"location":"#warp.mqtt_config","title":"<code>mqtt_config</code>","text":"<p>Created on 09.05.2025</p> <p>@author: wf</p>"},{"location":"#warp.mqtt_config.MqttConfig","title":"<code>MqttConfig</code>","text":"<p>Configuration for the MQTT to Warp3 middleware</p> Source code in <code>warp/mqtt_config.py</code> <pre><code>@lod_storable\nclass MqttConfig:\n    \"\"\"Configuration for the MQTT to Warp3 middleware\"\"\"\n\n    mqtt_broker: str = \"mqtt.bitplan.com\"\n    mqtt_port: int = 1883\n    mqtt_topic: str = \"tele/data\"\n    mqtt_username: Optional[str] = None\n    mqtt_password: Optional[str] = None\n    dry_run: bool = False\n\n    @classmethod\n    def ofArgs(cls, args: Namespace = None):\n        \"\"\"\n        Create a configuration from command line arguments.\n\n        Args:\n            args: Optional list of command line arguments. If None, sys.argv is used.\n\n        Returns:\n            MqttConfig: Configuration object\n        \"\"\"\n        if args is None:\n            config = cls()\n        else:\n            config = cls(\n                mqtt_broker=args.mqtt_broker,\n                mqtt_port=args.mqtt_port,\n                mqtt_topic=args.mqtt_topic,\n                mqtt_username=args.mqtt_username,\n                mqtt_password=args.mqtt_password,\n                dry_run=args.dry_run,\n            )\n        return config\n\n    @classmethod\n    def addArgs(cls, parser):\n        \"\"\"\n        Add command line arguments for MqttConfig to the given parser.\n\n        Args:\n            parser: The argument parser to add arguments to\n        \"\"\"\n        parser.add_argument(\n            \"--mqtt-broker\", help=\"MQTT broker address\", default=cls.mqtt_broker\n        )\n        parser.add_argument(\n            \"--mqtt-port\", type=int, help=\"MQTT broker port\", default=cls.mqtt_port\n        )\n        parser.add_argument(\n            \"--mqtt-topic\", help=\"MQTT topic to subscribe to\", default=cls.mqtt_topic\n        )\n        parser.add_argument(\n            \"--mqtt-username\", help=\"MQTT username\", default=cls.mqtt_username\n        )\n        parser.add_argument(\n            \"--mqtt-password\", help=\"MQTT password\", default=cls.mqtt_password\n        )\n        parser.add_argument(\n            \"--dry-run\", action=\"store_true\", help=\"Run without updating the wallbox\"\n        )\n\n    @classmethod\n    def ofYaml(cls, yaml_path):\n        config = cls.load_from_yaml_file(yaml_path)\n        return config\n</code></pre>"},{"location":"#warp.mqtt_config.MqttConfig.addArgs","title":"<code>addArgs(parser)</code>  <code>classmethod</code>","text":"<p>Add command line arguments for MqttConfig to the given parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <p>The argument parser to add arguments to</p> required Source code in <code>warp/mqtt_config.py</code> <pre><code>@classmethod\ndef addArgs(cls, parser):\n    \"\"\"\n    Add command line arguments for MqttConfig to the given parser.\n\n    Args:\n        parser: The argument parser to add arguments to\n    \"\"\"\n    parser.add_argument(\n        \"--mqtt-broker\", help=\"MQTT broker address\", default=cls.mqtt_broker\n    )\n    parser.add_argument(\n        \"--mqtt-port\", type=int, help=\"MQTT broker port\", default=cls.mqtt_port\n    )\n    parser.add_argument(\n        \"--mqtt-topic\", help=\"MQTT topic to subscribe to\", default=cls.mqtt_topic\n    )\n    parser.add_argument(\n        \"--mqtt-username\", help=\"MQTT username\", default=cls.mqtt_username\n    )\n    parser.add_argument(\n        \"--mqtt-password\", help=\"MQTT password\", default=cls.mqtt_password\n    )\n    parser.add_argument(\n        \"--dry-run\", action=\"store_true\", help=\"Run without updating the wallbox\"\n    )\n</code></pre>"},{"location":"#warp.mqtt_config.MqttConfig.ofArgs","title":"<code>ofArgs(args=None)</code>  <code>classmethod</code>","text":"<p>Create a configuration from command line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Optional list of command line arguments. If None, sys.argv is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MqttConfig</code> <p>Configuration object</p> Source code in <code>warp/mqtt_config.py</code> <pre><code>@classmethod\ndef ofArgs(cls, args: Namespace = None):\n    \"\"\"\n    Create a configuration from command line arguments.\n\n    Args:\n        args: Optional list of command line arguments. If None, sys.argv is used.\n\n    Returns:\n        MqttConfig: Configuration object\n    \"\"\"\n    if args is None:\n        config = cls()\n    else:\n        config = cls(\n            mqtt_broker=args.mqtt_broker,\n            mqtt_port=args.mqtt_port,\n            mqtt_topic=args.mqtt_topic,\n            mqtt_username=args.mqtt_username,\n            mqtt_password=args.mqtt_password,\n            dry_run=args.dry_run,\n        )\n    return config\n</code></pre>"},{"location":"#warp.warp3","title":"<code>warp3</code>","text":"<p>Created on 2025-05-09</p> <p>@author: wf</p>"},{"location":"#warp.warp3.MeterReading","title":"<code>MeterReading</code>  <code>dataclass</code>","text":"Source code in <code>warp/warp3.py</code> <pre><code>@dataclass\nclass MeterReading:\n    kWh_in: float\n    kWh_out: float\n    time_stamp: str\n\n    @property\n    def time(self) -&gt; datetime:\n        \"\"\"Convert timestamp string to datetime object\"\"\"\n        return datetime.strptime(self.time_stamp, \"%Y-%m-%dT%H:%M:%S\")\n\n    def active_power(self, prev: \"MeterReading\") -&gt; float:\n        \"\"\"\n        calculate the active power\n        \"\"\"\n        # Time difference in hours\n        time_delta = (self.time - prev.time).total_seconds() / 3600\n        # Energy change (kWh)\n        energy_delta = (self.kWh_in - prev.kWh_in) - (self.kWh_out - prev.kWh_out)\n\n        # Power in watts\n        active_power = (energy_delta * 1000) / time_delta\n        return active_power\n</code></pre>"},{"location":"#warp.warp3.MeterReading.time","title":"<code>time: datetime</code>  <code>property</code>","text":"<p>Convert timestamp string to datetime object</p>"},{"location":"#warp.warp3.MeterReading.active_power","title":"<code>active_power(prev)</code>","text":"<p>calculate the active power</p> Source code in <code>warp/warp3.py</code> <pre><code>def active_power(self, prev: \"MeterReading\") -&gt; float:\n    \"\"\"\n    calculate the active power\n    \"\"\"\n    # Time difference in hours\n    time_delta = (self.time - prev.time).total_seconds() / 3600\n    # Energy change (kWh)\n    energy_delta = (self.kWh_in - prev.kWh_in) - (self.kWh_out - prev.kWh_out)\n\n    # Power in watts\n    active_power = (energy_delta * 1000) / time_delta\n    return active_power\n</code></pre>"},{"location":"#warp.warp3.PowerMeter","title":"<code>PowerMeter</code>","text":"<p>Active power meter for Warp3 Wallbox</p> Source code in <code>warp/warp3.py</code> <pre><code>class PowerMeter:\n    \"\"\"Active power meter for Warp3 Wallbox\"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.logger = logging.getLogger(__name__)\n        self.warp3_api = None\n        self._timer = None\n        self._latest_active_power = None\n        self._active_power_lock = threading.Lock()\n\n    def setup_logging(self, debug=False):\n        level = logging.DEBUG if debug else logging.INFO\n        logging.basicConfig(\n            level=level,\n            format=\"%(asctime)s - %(levelname)s - %(message)s\",\n            handlers=[logging.StreamHandler(sys.stdout)],\n        )\n        self.logger = logging.getLogger(__name__)\n\n    def schedule_update(self):\n        \"\"\"Schedule next update using a timer\"\"\"\n        self._timer = threading.Timer(self.wallbox_config.update_interval, self.send_update)\n        self._timer.daemon = True\n        self._timer.start()\n\n    def check_warp3_availability(self) -&gt; bool:\n        \"\"\"\n        Check availability of Warp3 API by verifying firmware version and meter configuration.\n\n        Returns:\n            True if both firmware info and meter config are available, else False.\n        \"\"\"\n        # Check version\n        version_info = self.warp3_api.get_version()\n        if not version_info:\n            self.logger.error(\"\u274c Cannot connect to Warp3 API\")\n            available = False\n        else:\n            firmware = version_info.get(\"firmware\", \"unknown\")\n            self.logger.info(f\"\u2705 Connected to Warp3 - Firmware version: {firmware}\")\n\n            # Check meter\n            meter_id = self.wallbox_config.meter_id\n            meter_config = self.warp3_api.get_meter_config(meter_id)\n            if not meter_config:\n                self.logger.error(f\"\u274c Meter {meter_id} not available\")\n                available = False\n            else:\n                description = self.warp3_api.describe_meter(meter_config[1])\n                self.logger.info(f\"\u2705 {description}\")\n                available = True\n\n        return available\n\n    def handle_message(self, msg):\n        \"\"\"Handle incoming MQTT message\"\"\"\n        try:\n            payload = json.loads(msg.payload.decode())\n            active_power = self.wallbox_config.calcPower(payload)\n            if active_power:\n                self.update_wallbox(active_power)\n        except json.JSONDecodeError as jde:\n            self.logger.error(f\"JSON decode error: {str(jde)}\")\n        except Exception as e:\n            self.logger.error(f\"Error handling message: {str(e)}\")\n\n    def update_wallbox(self, power_value):\n        \"\"\"Send power value to wallbox\"\"\"\n        self.logger.info(f\"Power value: {power_value}W\")\n        with self._active_power_lock:\n            self._latest_active_power = power_value\n\n    def send_update(self):\n        \"\"\"\n        Send latest stored power value to wallbox\n        this is called regularly as per the scheduled interval\n        \"\"\"\n        with self._active_power_lock:\n            power_value = self._latest_active_power\n        if power_value is not None:\n            self.warp3_api.update_meter(power_value, self.wallbox_config.meter_id)\n        #re-schedule\n        self.schedule_update()\n\n    def start(self):\n        \"\"\"Start the power meter\"\"\"\n        # Set up logging\n        self.setup_logging(self.args.debug)\n\n        # Initialize Warp3 API\n        self.warp3_api = Warp3Api(self.wallbox_config.wallbox_host)\n\n        # Log configuration\n        self.logger.info(\"Starting MQTT to Warp3 middleware\")\n        self.logger.info(f\"MQTT broker: {self.mqtt_config.mqtt_broker}\")\n        self.logger.info(f\"MQTT topic: {self.mqtt_config.mqtt_topic}\")\n        self.logger.info(f\"Wallbox host: {self.wallbox_config.wallbox_host}\")\n        self.logger.info(f\"Power tag: {self.wallbox_config.power_tag}\")\n        self.logger.info(f\"Meter ID: {self.wallbox_config.meter_id}\")\n\n        # Check API availability\n        if not self.check_warp3_availability():\n            self.logger.error(\"Cannot connect to Warp3 - exiting\")\n            sys.exit(1)\n\n        if not self.mqtt_config.dry_run:\n            self.schedule_update()\n\n        # Create and run client\n        client = MqttClient(self.mqtt_config, callback=self.handle_message)\n        client.run()\n\n    def maininstance(self):\n        \"\"\"Main instance setup and execution\"\"\"\n        # Parse arguments\n        self.parser = argparse.ArgumentParser(\n            description=\"MQTT to Warp3 Wallbox Middleware\"\n        )\n        self.parser.add_argument(\n            \"--config-path\", help=\"Path to YAML configuration file\"\n        )\n        MqttConfig.addArgs(self.parser)\n        WallboxConfig.addArgs(self.parser)\n        self.parser.add_argument(\n            \"--debug\", action=\"store_true\", help=\"Enable debug logging\"\n        )\n        self.args = self.parser.parse_args()\n\n        # Create configurations\n        if self.args.config_path:\n            self.logger = logging.getLogger(__name__)\n            self.logger.info(f\"Loading configuration from {self.args.config_path}\")\n            try:\n                self.mqtt_config = MqttConfig.ofYaml(self.args.config_path)\n                self.wallbox_config = WallboxConfig.ofYaml(self.args.config_path)\n            except Exception as e:\n                self.logger.error(f\"Failed to load configuration from YAML: {e}\")\n                sys.exit(1)\n        else:\n            self.mqtt_config = MqttConfig.ofArgs(self.args)\n            self.wallbox_config = WallboxConfig.ofArgs(self.args)\n\n        self.start()\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>warp/warp3.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.logger = logging.getLogger(__name__)\n    self.warp3_api = None\n    self._timer = None\n    self._latest_active_power = None\n    self._active_power_lock = threading.Lock()\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.check_warp3_availability","title":"<code>check_warp3_availability()</code>","text":"<p>Check availability of Warp3 API by verifying firmware version and meter configuration.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if both firmware info and meter config are available, else False.</p> Source code in <code>warp/warp3.py</code> <pre><code>def check_warp3_availability(self) -&gt; bool:\n    \"\"\"\n    Check availability of Warp3 API by verifying firmware version and meter configuration.\n\n    Returns:\n        True if both firmware info and meter config are available, else False.\n    \"\"\"\n    # Check version\n    version_info = self.warp3_api.get_version()\n    if not version_info:\n        self.logger.error(\"\u274c Cannot connect to Warp3 API\")\n        available = False\n    else:\n        firmware = version_info.get(\"firmware\", \"unknown\")\n        self.logger.info(f\"\u2705 Connected to Warp3 - Firmware version: {firmware}\")\n\n        # Check meter\n        meter_id = self.wallbox_config.meter_id\n        meter_config = self.warp3_api.get_meter_config(meter_id)\n        if not meter_config:\n            self.logger.error(f\"\u274c Meter {meter_id} not available\")\n            available = False\n        else:\n            description = self.warp3_api.describe_meter(meter_config[1])\n            self.logger.info(f\"\u2705 {description}\")\n            available = True\n\n    return available\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.handle_message","title":"<code>handle_message(msg)</code>","text":"<p>Handle incoming MQTT message</p> Source code in <code>warp/warp3.py</code> <pre><code>def handle_message(self, msg):\n    \"\"\"Handle incoming MQTT message\"\"\"\n    try:\n        payload = json.loads(msg.payload.decode())\n        active_power = self.wallbox_config.calcPower(payload)\n        if active_power:\n            self.update_wallbox(active_power)\n    except json.JSONDecodeError as jde:\n        self.logger.error(f\"JSON decode error: {str(jde)}\")\n    except Exception as e:\n        self.logger.error(f\"Error handling message: {str(e)}\")\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.maininstance","title":"<code>maininstance()</code>","text":"<p>Main instance setup and execution</p> Source code in <code>warp/warp3.py</code> <pre><code>def maininstance(self):\n    \"\"\"Main instance setup and execution\"\"\"\n    # Parse arguments\n    self.parser = argparse.ArgumentParser(\n        description=\"MQTT to Warp3 Wallbox Middleware\"\n    )\n    self.parser.add_argument(\n        \"--config-path\", help=\"Path to YAML configuration file\"\n    )\n    MqttConfig.addArgs(self.parser)\n    WallboxConfig.addArgs(self.parser)\n    self.parser.add_argument(\n        \"--debug\", action=\"store_true\", help=\"Enable debug logging\"\n    )\n    self.args = self.parser.parse_args()\n\n    # Create configurations\n    if self.args.config_path:\n        self.logger = logging.getLogger(__name__)\n        self.logger.info(f\"Loading configuration from {self.args.config_path}\")\n        try:\n            self.mqtt_config = MqttConfig.ofYaml(self.args.config_path)\n            self.wallbox_config = WallboxConfig.ofYaml(self.args.config_path)\n        except Exception as e:\n            self.logger.error(f\"Failed to load configuration from YAML: {e}\")\n            sys.exit(1)\n    else:\n        self.mqtt_config = MqttConfig.ofArgs(self.args)\n        self.wallbox_config = WallboxConfig.ofArgs(self.args)\n\n    self.start()\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.schedule_update","title":"<code>schedule_update()</code>","text":"<p>Schedule next update using a timer</p> Source code in <code>warp/warp3.py</code> <pre><code>def schedule_update(self):\n    \"\"\"Schedule next update using a timer\"\"\"\n    self._timer = threading.Timer(self.wallbox_config.update_interval, self.send_update)\n    self._timer.daemon = True\n    self._timer.start()\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.send_update","title":"<code>send_update()</code>","text":"<p>Send latest stored power value to wallbox this is called regularly as per the scheduled interval</p> Source code in <code>warp/warp3.py</code> <pre><code>def send_update(self):\n    \"\"\"\n    Send latest stored power value to wallbox\n    this is called regularly as per the scheduled interval\n    \"\"\"\n    with self._active_power_lock:\n        power_value = self._latest_active_power\n    if power_value is not None:\n        self.warp3_api.update_meter(power_value, self.wallbox_config.meter_id)\n    #re-schedule\n    self.schedule_update()\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.start","title":"<code>start()</code>","text":"<p>Start the power meter</p> Source code in <code>warp/warp3.py</code> <pre><code>def start(self):\n    \"\"\"Start the power meter\"\"\"\n    # Set up logging\n    self.setup_logging(self.args.debug)\n\n    # Initialize Warp3 API\n    self.warp3_api = Warp3Api(self.wallbox_config.wallbox_host)\n\n    # Log configuration\n    self.logger.info(\"Starting MQTT to Warp3 middleware\")\n    self.logger.info(f\"MQTT broker: {self.mqtt_config.mqtt_broker}\")\n    self.logger.info(f\"MQTT topic: {self.mqtt_config.mqtt_topic}\")\n    self.logger.info(f\"Wallbox host: {self.wallbox_config.wallbox_host}\")\n    self.logger.info(f\"Power tag: {self.wallbox_config.power_tag}\")\n    self.logger.info(f\"Meter ID: {self.wallbox_config.meter_id}\")\n\n    # Check API availability\n    if not self.check_warp3_availability():\n        self.logger.error(\"Cannot connect to Warp3 - exiting\")\n        sys.exit(1)\n\n    if not self.mqtt_config.dry_run:\n        self.schedule_update()\n\n    # Create and run client\n    client = MqttClient(self.mqtt_config, callback=self.handle_message)\n    client.run()\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.update_wallbox","title":"<code>update_wallbox(power_value)</code>","text":"<p>Send power value to wallbox</p> Source code in <code>warp/warp3.py</code> <pre><code>def update_wallbox(self, power_value):\n    \"\"\"Send power value to wallbox\"\"\"\n    self.logger.info(f\"Power value: {power_value}W\")\n    with self._active_power_lock:\n        self._latest_active_power = power_value\n</code></pre>"},{"location":"#warp.warp3.WallboxConfig","title":"<code>WallboxConfig</code>","text":"<p>Configuration for the Warp3 wallbox</p> Source code in <code>warp/warp3.py</code> <pre><code>@lod_storable\nclass WallboxConfig:\n    \"\"\"Configuration for the Warp3 wallbox\"\"\"\n\n    wallbox_host: str = \"http://warp3.mydomain\"\n    # example Tasmota reading\n    power_tag: str = \"eHZ\"        # json tag for the payload content\n    power_field: str = \"Power2\"   # active power (always positive)\n    in_field: str = \"E_in\"        # field for energy input\n    out_field: str = \"E_out\"      # field for energy output\n    time_field: str = \"Time\"      # field for timestamp\n    meter_id: int = 2             # id of the meter configured\n    update_interval:float = 1.0   # how often the API should fed\n\n\n    @classmethod\n    def ofArgs(cls, args: Namespace = None):\n        \"\"\"\n        Create a configuration from command line arguments.\n\n        Args:\n            args: Optional list of command line arguments. If None, sys.argv is used.\n\n        Returns:\n            WallboxConfig: Configuration object\n        \"\"\"\n        if args is None:\n            config = cls()\n        else:\n            config = cls(\n                wallbox_host=args.wallbox_host,\n                power_tag=args.power_tag,\n                power_field=args.power_field,\n                in_field=args.in_field,\n                out_field=args.out_field,\n                time_field=args.time_field,\n                meter_id=args.meter_id,\n                update_interval=args.update_interval,\n            )\n        return config\n\n    @classmethod\n    def addArgs(cls, parser):\n        \"\"\"\n        Add command line arguments for WallboxConfig to the given parser.\n\n        Args:\n            parser: The argument parser to add arguments to\n        \"\"\"\n        parser.add_argument(\n            \"--wallbox-host\", help=\"Wallbox host URL\", default=cls.wallbox_host\n        )\n        parser.add_argument(\n            \"--power-tag\",\n            help=\"Tag in MQTT data containing power information\",\n            default=cls.power_tag,\n        )\n        parser.add_argument(\n            \"--power-field\",\n            help=\"Field name in MQTT data containing active power value\",\n            default=cls.power_field,\n        )\n        parser.add_argument(\n            \"--in-field\",\n            help=\"Field name in MQTT data containing energy input\",\n            default=cls.in_field,\n        )\n        parser.add_argument(\n            \"--out-field\",\n            help=\"Field name in MQTT data containing energy output\",\n            default=cls.out_field,\n        )\n        parser.add_argument(\n            \"--time-field\",\n            help=\"Field name in MQTT data containing timestamp\",\n            default=cls.time_field,\n        )\n        parser.add_argument(\n            \"--meter-id\", type=int, help=\"Meter ID to use\", default=cls.meter_id\n        )\n        parser.add_argument(\n            \"--update-interval\",\n            type=float,\n            help=\"Minimum update interval in seconds\",\n            default=cls.update_interval,\n        )\n\n    @classmethod\n    def ofYaml(cls, yaml_path):\n        config = cls.load_from_yaml_file(yaml_path)\n        return config\n\n    def calcPower(self, payload) -&gt; float:\n        \"\"\"\n        Calculate power from payload using MeterReading class.\n\n        Args:\n            payload: The decoded JSON payload from MQTT message\n\n        Returns:\n            float: Calculated power in watts\n        \"\"\"\n        # get the timestamp\n        timestamp_str = payload.get(self.time_field)\n        # Get the data from the payload\n        data = payload.get(self.power_tag, {})\n\n        # Extract values\n        e_in = data.get(self.in_field)\n        e_out = data.get(self.out_field)\n        power_magnitude = data.get(self.power_field)\n\n        # Create current reading\n        current = MeterReading(kWh_in=e_in, kWh_out=e_out, time_stamp=timestamp_str)\n        # If we don't have a previous reading, store this one and return fallback power\n        if not hasattr(self, \"_last_reading\"):\n            active_power = None\n        else:\n            # calc power roughly from meter reading\n            active_power = current.active_power(self._last_reading)\n            # if we have a precise power magnitude we will use it:\n            if power_magnitude:\n                delta_in = e_in - self._last_reading.kWh_in\n                delta_out = e_out - self._last_reading.kWh_out\n                sign = 1 if delta_in &gt;= delta_out else -1\n                active_power=sign*power_magnitude\n            active_power=round(active_power)\n\n        # Update stored reading\n        self._last_reading = current\n        return active_power\n</code></pre>"},{"location":"#warp.warp3.WallboxConfig.addArgs","title":"<code>addArgs(parser)</code>  <code>classmethod</code>","text":"<p>Add command line arguments for WallboxConfig to the given parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <p>The argument parser to add arguments to</p> required Source code in <code>warp/warp3.py</code> <pre><code>@classmethod\ndef addArgs(cls, parser):\n    \"\"\"\n    Add command line arguments for WallboxConfig to the given parser.\n\n    Args:\n        parser: The argument parser to add arguments to\n    \"\"\"\n    parser.add_argument(\n        \"--wallbox-host\", help=\"Wallbox host URL\", default=cls.wallbox_host\n    )\n    parser.add_argument(\n        \"--power-tag\",\n        help=\"Tag in MQTT data containing power information\",\n        default=cls.power_tag,\n    )\n    parser.add_argument(\n        \"--power-field\",\n        help=\"Field name in MQTT data containing active power value\",\n        default=cls.power_field,\n    )\n    parser.add_argument(\n        \"--in-field\",\n        help=\"Field name in MQTT data containing energy input\",\n        default=cls.in_field,\n    )\n    parser.add_argument(\n        \"--out-field\",\n        help=\"Field name in MQTT data containing energy output\",\n        default=cls.out_field,\n    )\n    parser.add_argument(\n        \"--time-field\",\n        help=\"Field name in MQTT data containing timestamp\",\n        default=cls.time_field,\n    )\n    parser.add_argument(\n        \"--meter-id\", type=int, help=\"Meter ID to use\", default=cls.meter_id\n    )\n    parser.add_argument(\n        \"--update-interval\",\n        type=float,\n        help=\"Minimum update interval in seconds\",\n        default=cls.update_interval,\n    )\n</code></pre>"},{"location":"#warp.warp3.WallboxConfig.calcPower","title":"<code>calcPower(payload)</code>","text":"<p>Calculate power from payload using MeterReading class.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <p>The decoded JSON payload from MQTT message</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Calculated power in watts</p> Source code in <code>warp/warp3.py</code> <pre><code>def calcPower(self, payload) -&gt; float:\n    \"\"\"\n    Calculate power from payload using MeterReading class.\n\n    Args:\n        payload: The decoded JSON payload from MQTT message\n\n    Returns:\n        float: Calculated power in watts\n    \"\"\"\n    # get the timestamp\n    timestamp_str = payload.get(self.time_field)\n    # Get the data from the payload\n    data = payload.get(self.power_tag, {})\n\n    # Extract values\n    e_in = data.get(self.in_field)\n    e_out = data.get(self.out_field)\n    power_magnitude = data.get(self.power_field)\n\n    # Create current reading\n    current = MeterReading(kWh_in=e_in, kWh_out=e_out, time_stamp=timestamp_str)\n    # If we don't have a previous reading, store this one and return fallback power\n    if not hasattr(self, \"_last_reading\"):\n        active_power = None\n    else:\n        # calc power roughly from meter reading\n        active_power = current.active_power(self._last_reading)\n        # if we have a precise power magnitude we will use it:\n        if power_magnitude:\n            delta_in = e_in - self._last_reading.kWh_in\n            delta_out = e_out - self._last_reading.kWh_out\n            sign = 1 if delta_in &gt;= delta_out else -1\n            active_power=sign*power_magnitude\n        active_power=round(active_power)\n\n    # Update stored reading\n    self._last_reading = current\n    return active_power\n</code></pre>"},{"location":"#warp.warp3.WallboxConfig.ofArgs","title":"<code>ofArgs(args=None)</code>  <code>classmethod</code>","text":"<p>Create a configuration from command line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Optional list of command line arguments. If None, sys.argv is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>WallboxConfig</code> <p>Configuration object</p> Source code in <code>warp/warp3.py</code> <pre><code>@classmethod\ndef ofArgs(cls, args: Namespace = None):\n    \"\"\"\n    Create a configuration from command line arguments.\n\n    Args:\n        args: Optional list of command line arguments. If None, sys.argv is used.\n\n    Returns:\n        WallboxConfig: Configuration object\n    \"\"\"\n    if args is None:\n        config = cls()\n    else:\n        config = cls(\n            wallbox_host=args.wallbox_host,\n            power_tag=args.power_tag,\n            power_field=args.power_field,\n            in_field=args.in_field,\n            out_field=args.out_field,\n            time_field=args.time_field,\n            meter_id=args.meter_id,\n            update_interval=args.update_interval,\n        )\n    return config\n</code></pre>"},{"location":"#warp.warp3.main","title":"<code>main()</code>","text":"<p>Main entry point</p> Source code in <code>warp/warp3.py</code> <pre><code>def main():\n    \"\"\"Main entry point\"\"\"\n    pm = PowerMeter()\n    pm.maininstance()\n</code></pre>"},{"location":"#warp.warp3_api","title":"<code>warp3_api</code>","text":"<p>Created on 2025-05-09</p> <p>@author: wf</p>"},{"location":"#warp.warp3_api.Warp3Api","title":"<code>Warp3Api</code>","text":"<p>API client for TinkerForge/Warp3 Wallbox</p> Source code in <code>warp/warp3_api.py</code> <pre><code>class Warp3Api:\n    \"\"\"API client for TinkerForge/Warp3 Wallbox\"\"\"\n\n    def __init__(self, host):\n        \"\"\"Initialize with wallbox host\"\"\"\n        self.host = host.rstrip(\"/\")\n        self.logger = logging.getLogger(__name__)\n        self.meter_values={}\n\n    def api_get(self, cmd):\n        \"\"\"\n        Call the wallbox API with the given command and filter the JSON result\n\n        Args:\n            cmd: API command\n\n\n        Returns:\n            API response\n        \"\"\"\n        api_response = None\n        try:\n            http_response = requests.get(f\"{self.host}/{cmd}\")\n            http_response.raise_for_status()\n            api_response = http_response.json()\n        except Exception as e:\n            self.logger.error(f\"API GET error: {e}\")\n        return api_response\n\n    def get_version(self):\n        \"\"\"Get wallbox firmware version\"\"\"\n        version_info = self.api_get(\"info/version\")\n        return version_info\n\n    def get_meter_config(self, meter_id=1):\n        \"\"\"Get meter configuration\"\"\"\n        meter_config = self.api_get(f\"meters/{meter_id}/config\")\n        return meter_config\n\n    def update_meter(self, value, meter_id=1):\n        \"\"\"\n        Update meter value\n\n        Args:\n            value: Power value in Watts\n            meter_id: Meter ID (default 1)\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        update_success = False\n        try:\n            url = f\"{self.host}/meters/{meter_id}/update\"\n            http_response = requests.post(url, data=f\"[{value}]\")\n            if http_response.status_code == 200 and not http_response.text:\n\n                prev=self.meter_values.get(meter_id)\n                if not prev or prev!=value:\n                    msg=f\"\u2705 {value} Watt set for meter {meter_id}\"\n                    self.logger.info(msg)\n                self.meter_values[meter_id]=value\n                update_success = True\n            else:\n                self.logger.error(f\"\u274c Failed to update: {http_response.text}\")\n        except Exception as e:\n            self.logger.error(f\"Error updating meter: {e}\")\n        return update_success\n\n    def describe_meter(self, meter: dict) -&gt; str:\n        \"\"\"\n        Describe the meter configuration using value_id explanations.\n\n        Args:\n            meter: The meter configuration dictionary.\n\n        Returns:\n            A human-readable description string.\n        \"\"\"\n        name = meter.get('display_name', 'Unknown')\n        location = meter.get('location', 'N/A')\n        value_ids = meter.get('value_ids', [])\n        values_explained = ', '.join(\n            f\"{vid}: {self.explain_value_id(vid)}\" for vid in value_ids\n        )\n        description = f\"Meter '{name}' at location {location} measures: {values_explained}\"\n        return description\n\n    def explain_value_id(self,value_id: int) -&gt; str:\n        explanations = {\n            1: \"Spannung L1-N\",\n            2: \"Spannung L2-N\",\n            3: \"Spannung L3-N\",\n            4: \"Spannung L1-L2\",\n            5: \"Spannung L2-L3\",\n            6: \"Spannung L3-L1\",\n            7: \"Durchschnittliche Phasenspannung\",\n            8: \"Durchschnitt Spannung L1-L2, L2-L3, L3-L1\",\n            13: \"Strom (Bezug + Einspeisung)\",\n            17: \"Strom (Bezug + Einspeisung)\",\n            21: \"Strom (Bezug + Einspeisung)\",\n            25: \"Neutralleiterstrom\",\n            29: \"Durchschnitt der Phasenstr\u00f6me\",\n            33: \"Summe der Phasenstr\u00f6me\",\n            39: \"Wirkleistung (Bezug - Einspeisung)\",\n            48: \"Wirkleistung (Bezug - Einspeisung)\",\n            57: \"Wirkleistung (Bezug - Einspeisung)\",\n            74: \"Summe der Phasenwirkleistungen (Bezug - Einspeisung)\",\n            83: \"Blindleistung (induktiv - kapazitiv)\",\n            91: \"Blindleistung (induktiv - kapazitiv)\",\n            99: \"Blindleistung (induktiv - kapazitiv)\",\n            115: \"Summe der Phasenblindleistungen\",\n            122: \"Scheinleistung (Bezug + Einspeisung)\",\n            130: \"Scheinleistung (Bezug + Einspeisung)\",\n            138: \"Scheinleistung (Bezug + Einspeisung)\",\n            154: \"Summe der Phasenscheinleistungen\",\n            209: \"Wirkenergie Bezug (seit Herstellung)\",\n            210: \"Wirkenergie Bezug (seit letztem Zur\u00fccksetzen)\",\n            211: \"Wirkenergie Einspeisung (seit Herstellung)\",\n            212: \"Wirkenergie Einspeisung (seit letztem Zur\u00fccksetzen)\",\n            213: \"Wirkenergie Bezug + Einspeisung (seit Herstellung)\",\n            214: \"Wirkenergie Bezug + Einspeisung (seit letztem Zur\u00fccksetzen)\",\n            277: \"Blindenergie induktiv + kapazitiv (seit Herstellung)\",\n            353: \"Leistungsfaktor (gerichtet)\",\n            354: \"Leistungsfaktor (gerichtet)\",\n            355: \"Leistungsfaktor (gerichtet)\",\n            356: \"Summe der gerichteten Leistungsfaktoren\",\n            364: \"Netzfrequenz\",\n        }\n        return explanations.get(value_id, \"Unknown value_id\")\n</code></pre>"},{"location":"#warp.warp3_api.Warp3Api.__init__","title":"<code>__init__(host)</code>","text":"<p>Initialize with wallbox host</p> Source code in <code>warp/warp3_api.py</code> <pre><code>def __init__(self, host):\n    \"\"\"Initialize with wallbox host\"\"\"\n    self.host = host.rstrip(\"/\")\n    self.logger = logging.getLogger(__name__)\n    self.meter_values={}\n</code></pre>"},{"location":"#warp.warp3_api.Warp3Api.api_get","title":"<code>api_get(cmd)</code>","text":"<p>Call the wallbox API with the given command and filter the JSON result</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <p>API command</p> required <p>Returns:</p> Type Description <p>API response</p> Source code in <code>warp/warp3_api.py</code> <pre><code>def api_get(self, cmd):\n    \"\"\"\n    Call the wallbox API with the given command and filter the JSON result\n\n    Args:\n        cmd: API command\n\n\n    Returns:\n        API response\n    \"\"\"\n    api_response = None\n    try:\n        http_response = requests.get(f\"{self.host}/{cmd}\")\n        http_response.raise_for_status()\n        api_response = http_response.json()\n    except Exception as e:\n        self.logger.error(f\"API GET error: {e}\")\n    return api_response\n</code></pre>"},{"location":"#warp.warp3_api.Warp3Api.describe_meter","title":"<code>describe_meter(meter)</code>","text":"<p>Describe the meter configuration using value_id explanations.</p> <p>Parameters:</p> Name Type Description Default <code>meter</code> <code>dict</code> <p>The meter configuration dictionary.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A human-readable description string.</p> Source code in <code>warp/warp3_api.py</code> <pre><code>def describe_meter(self, meter: dict) -&gt; str:\n    \"\"\"\n    Describe the meter configuration using value_id explanations.\n\n    Args:\n        meter: The meter configuration dictionary.\n\n    Returns:\n        A human-readable description string.\n    \"\"\"\n    name = meter.get('display_name', 'Unknown')\n    location = meter.get('location', 'N/A')\n    value_ids = meter.get('value_ids', [])\n    values_explained = ', '.join(\n        f\"{vid}: {self.explain_value_id(vid)}\" for vid in value_ids\n    )\n    description = f\"Meter '{name}' at location {location} measures: {values_explained}\"\n    return description\n</code></pre>"},{"location":"#warp.warp3_api.Warp3Api.get_meter_config","title":"<code>get_meter_config(meter_id=1)</code>","text":"<p>Get meter configuration</p> Source code in <code>warp/warp3_api.py</code> <pre><code>def get_meter_config(self, meter_id=1):\n    \"\"\"Get meter configuration\"\"\"\n    meter_config = self.api_get(f\"meters/{meter_id}/config\")\n    return meter_config\n</code></pre>"},{"location":"#warp.warp3_api.Warp3Api.get_version","title":"<code>get_version()</code>","text":"<p>Get wallbox firmware version</p> Source code in <code>warp/warp3_api.py</code> <pre><code>def get_version(self):\n    \"\"\"Get wallbox firmware version\"\"\"\n    version_info = self.api_get(\"info/version\")\n    return version_info\n</code></pre>"},{"location":"#warp.warp3_api.Warp3Api.update_meter","title":"<code>update_meter(value, meter_id=1)</code>","text":"<p>Update meter value</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>Power value in Watts</p> required <code>meter_id</code> <p>Meter ID (default 1)</p> <code>1</code> <p>Returns:</p> Type Description <p>True if successful, False otherwise</p> Source code in <code>warp/warp3_api.py</code> <pre><code>def update_meter(self, value, meter_id=1):\n    \"\"\"\n    Update meter value\n\n    Args:\n        value: Power value in Watts\n        meter_id: Meter ID (default 1)\n\n    Returns:\n        True if successful, False otherwise\n    \"\"\"\n    update_success = False\n    try:\n        url = f\"{self.host}/meters/{meter_id}/update\"\n        http_response = requests.post(url, data=f\"[{value}]\")\n        if http_response.status_code == 200 and not http_response.text:\n\n            prev=self.meter_values.get(meter_id)\n            if not prev or prev!=value:\n                msg=f\"\u2705 {value} Watt set for meter {meter_id}\"\n                self.logger.info(msg)\n            self.meter_values[meter_id]=value\n            update_success = True\n        else:\n            self.logger.error(f\"\u274c Failed to update: {http_response.text}\")\n    except Exception as e:\n        self.logger.error(f\"Error updating meter: {e}\")\n    return update_success\n</code></pre>"}]}