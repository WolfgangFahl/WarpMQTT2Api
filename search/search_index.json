{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WarpMQTT2Api API Documentation","text":""},{"location":"#warp.mqtt_client","title":"<code>mqtt_client</code>","text":"<p>Created on 09.05.2025</p> <p>@author: wf</p>"},{"location":"#warp.mqtt_client.MqttClient","title":"<code>MqttClient</code>","text":"<p>MQTT client</p> Source code in <code>warp/mqtt_client.py</code> <pre><code>class MqttClient:\n    \"\"\"MQTT client\"\"\"\n\n    def __init__(self, mqtt_config: MqttConfig, callback):\n        \"\"\"Initialize with configurations\"\"\"\n        self.mqtt_config = mqtt_config\n        self.client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self.callback = callback\n\n    def on_connect(self, client, userdata, flags, rc, properties=None):\n        \"\"\"Connection callback\"\"\"\n        if userdata or flags or properties:\n            pass\n\n        if rc == 0:\n            logger.info(f\"Connected to MQTT broker at {self.mqtt_config.mqtt_broker}\")\n            client.subscribe(self.mqtt_config.mqtt_topic)\n            logger.info(f\"Subscribed to {self.mqtt_config.mqtt_topic}\")\n        else:\n            logger.error(f\"Failed to connect, return code {rc}\")\n\n    def on_message(self, client, userdata, msg):\n        \"\"\"Message callback\"\"\"\n        if client or userdata:\n            pass\n        if isinstance(msg, mqtt.MQTTMessage):\n            logger.debug(f\"Message received: {msg.topic}\")\n            self.callback(msg)\n\n    def run(self):\n        \"\"\"Run the client loop\"\"\"\n        # Set up auth if needed\n        if self.mqtt_config.mqtt_username and self.mqtt_config.mqtt_password:\n            self.client.username_pw_set(\n                self.mqtt_config.mqtt_username, self.mqtt_config.mqtt_password\n            )\n\n        # Connect to broker\n        try:\n            self.client.connect(\n                self.mqtt_config.mqtt_broker, self.mqtt_config.mqtt_port\n            )\n        except Exception as e:\n            logger.error(f\"Connection failed: {e}\")\n            return False\n\n        # Start loop\n        try:\n            logger.info(\"Starting MQTT loop\")\n            self.client.loop_forever()\n        except KeyboardInterrupt:\n            logger.info(\"Stopping client\")\n        except Exception as e:\n            logger.error(f\"Error in loop: {e}\")\n        finally:\n            self.client.disconnect()\n\n        return True\n</code></pre>"},{"location":"#warp.mqtt_client.MqttClient.__init__","title":"<code>__init__(mqtt_config, callback)</code>","text":"<p>Initialize with configurations</p> Source code in <code>warp/mqtt_client.py</code> <pre><code>def __init__(self, mqtt_config: MqttConfig, callback):\n    \"\"\"Initialize with configurations\"\"\"\n    self.mqtt_config = mqtt_config\n    self.client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)\n    self.client.on_connect = self.on_connect\n    self.client.on_message = self.on_message\n    self.callback = callback\n</code></pre>"},{"location":"#warp.mqtt_client.MqttClient.on_connect","title":"<code>on_connect(client, userdata, flags, rc, properties=None)</code>","text":"<p>Connection callback</p> Source code in <code>warp/mqtt_client.py</code> <pre><code>def on_connect(self, client, userdata, flags, rc, properties=None):\n    \"\"\"Connection callback\"\"\"\n    if userdata or flags or properties:\n        pass\n\n    if rc == 0:\n        logger.info(f\"Connected to MQTT broker at {self.mqtt_config.mqtt_broker}\")\n        client.subscribe(self.mqtt_config.mqtt_topic)\n        logger.info(f\"Subscribed to {self.mqtt_config.mqtt_topic}\")\n    else:\n        logger.error(f\"Failed to connect, return code {rc}\")\n</code></pre>"},{"location":"#warp.mqtt_client.MqttClient.on_message","title":"<code>on_message(client, userdata, msg)</code>","text":"<p>Message callback</p> Source code in <code>warp/mqtt_client.py</code> <pre><code>def on_message(self, client, userdata, msg):\n    \"\"\"Message callback\"\"\"\n    if client or userdata:\n        pass\n    if isinstance(msg, mqtt.MQTTMessage):\n        logger.debug(f\"Message received: {msg.topic}\")\n        self.callback(msg)\n</code></pre>"},{"location":"#warp.mqtt_client.MqttClient.run","title":"<code>run()</code>","text":"<p>Run the client loop</p> Source code in <code>warp/mqtt_client.py</code> <pre><code>def run(self):\n    \"\"\"Run the client loop\"\"\"\n    # Set up auth if needed\n    if self.mqtt_config.mqtt_username and self.mqtt_config.mqtt_password:\n        self.client.username_pw_set(\n            self.mqtt_config.mqtt_username, self.mqtt_config.mqtt_password\n        )\n\n    # Connect to broker\n    try:\n        self.client.connect(\n            self.mqtt_config.mqtt_broker, self.mqtt_config.mqtt_port\n        )\n    except Exception as e:\n        logger.error(f\"Connection failed: {e}\")\n        return False\n\n    # Start loop\n    try:\n        logger.info(\"Starting MQTT loop\")\n        self.client.loop_forever()\n    except KeyboardInterrupt:\n        logger.info(\"Stopping client\")\n    except Exception as e:\n        logger.error(f\"Error in loop: {e}\")\n    finally:\n        self.client.disconnect()\n\n    return True\n</code></pre>"},{"location":"#warp.mqtt_config","title":"<code>mqtt_config</code>","text":"<p>Created on 09.05.2025</p> <p>@author: wf</p>"},{"location":"#warp.mqtt_config.MqttConfig","title":"<code>MqttConfig</code>","text":"<p>Configuration for the MQTT to Warp3 middleware</p> Source code in <code>warp/mqtt_config.py</code> <pre><code>@lod_storable\nclass MqttConfig:\n    \"\"\"Configuration for the MQTT to Warp3 middleware\"\"\"\n\n    mqtt_broker: str = \"mqtt.bitplan.com\"\n    mqtt_port: int = 1883\n    mqtt_topic: str = \"tele/data\"\n    mqtt_username: Optional[str] = None\n    mqtt_password: Optional[str] = None\n    update_interval: int = 10  # seconds\n    dry_run: bool = False\n\n    @classmethod\n    def ofArgs(cls, args: Namespace = None):\n        \"\"\"\n        Create a configuration from command line arguments.\n\n        Args:\n            args: Optional list of command line arguments. If None, sys.argv is used.\n\n        Returns:\n            MqttConfig: Configuration object\n        \"\"\"\n        if args is None:\n            config = cls()\n        else:\n            config = cls(\n                mqtt_broker=args.mqtt_broker,\n                mqtt_port=args.mqtt_port,\n                mqtt_topic=args.mqtt_topic,\n                mqtt_username=args.mqtt_username,\n                mqtt_password=args.mqtt_password,\n                update_interval=args.update_interval,\n                dry_run=args.dry_run,\n            )\n        return config\n\n    @classmethod\n    def addArgs(cls, parser):\n        \"\"\"\n        Add command line arguments for MqttConfig to the given parser.\n\n        Args:\n            parser: The argument parser to add arguments to\n        \"\"\"\n        parser.add_argument(\n            \"--mqtt-broker\", help=\"MQTT broker address\", default=cls.mqtt_broker\n        )\n        parser.add_argument(\n            \"--mqtt-port\", type=int, help=\"MQTT broker port\", default=cls.mqtt_port\n        )\n        parser.add_argument(\n            \"--mqtt-topic\", help=\"MQTT topic to subscribe to\", default=cls.mqtt_topic\n        )\n        parser.add_argument(\n            \"--mqtt-username\", help=\"MQTT username\", default=cls.mqtt_username\n        )\n        parser.add_argument(\n            \"--mqtt-password\", help=\"MQTT password\", default=cls.mqtt_password\n        )\n        parser.add_argument(\n            \"--update-interval\",\n            type=int,\n            help=\"Minimum update interval in seconds\",\n            default=cls.update_interval,\n        )\n        parser.add_argument(\n            \"--dry-run\", action=\"store_true\", help=\"Run without updating the wallbox\"\n        )\n\n    @classmethod\n    def ofYaml(cls, yaml_path):\n        config = cls.load_from_yaml_file(yaml_path)\n        return config\n</code></pre>"},{"location":"#warp.mqtt_config.MqttConfig.addArgs","title":"<code>addArgs(parser)</code>  <code>classmethod</code>","text":"<p>Add command line arguments for MqttConfig to the given parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <p>The argument parser to add arguments to</p> required Source code in <code>warp/mqtt_config.py</code> <pre><code>@classmethod\ndef addArgs(cls, parser):\n    \"\"\"\n    Add command line arguments for MqttConfig to the given parser.\n\n    Args:\n        parser: The argument parser to add arguments to\n    \"\"\"\n    parser.add_argument(\n        \"--mqtt-broker\", help=\"MQTT broker address\", default=cls.mqtt_broker\n    )\n    parser.add_argument(\n        \"--mqtt-port\", type=int, help=\"MQTT broker port\", default=cls.mqtt_port\n    )\n    parser.add_argument(\n        \"--mqtt-topic\", help=\"MQTT topic to subscribe to\", default=cls.mqtt_topic\n    )\n    parser.add_argument(\n        \"--mqtt-username\", help=\"MQTT username\", default=cls.mqtt_username\n    )\n    parser.add_argument(\n        \"--mqtt-password\", help=\"MQTT password\", default=cls.mqtt_password\n    )\n    parser.add_argument(\n        \"--update-interval\",\n        type=int,\n        help=\"Minimum update interval in seconds\",\n        default=cls.update_interval,\n    )\n    parser.add_argument(\n        \"--dry-run\", action=\"store_true\", help=\"Run without updating the wallbox\"\n    )\n</code></pre>"},{"location":"#warp.mqtt_config.MqttConfig.ofArgs","title":"<code>ofArgs(args=None)</code>  <code>classmethod</code>","text":"<p>Create a configuration from command line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Optional list of command line arguments. If None, sys.argv is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MqttConfig</code> <p>Configuration object</p> Source code in <code>warp/mqtt_config.py</code> <pre><code>@classmethod\ndef ofArgs(cls, args: Namespace = None):\n    \"\"\"\n    Create a configuration from command line arguments.\n\n    Args:\n        args: Optional list of command line arguments. If None, sys.argv is used.\n\n    Returns:\n        MqttConfig: Configuration object\n    \"\"\"\n    if args is None:\n        config = cls()\n    else:\n        config = cls(\n            mqtt_broker=args.mqtt_broker,\n            mqtt_port=args.mqtt_port,\n            mqtt_topic=args.mqtt_topic,\n            mqtt_username=args.mqtt_username,\n            mqtt_password=args.mqtt_password,\n            update_interval=args.update_interval,\n            dry_run=args.dry_run,\n        )\n    return config\n</code></pre>"},{"location":"#warp.warp3","title":"<code>warp3</code>","text":"<p>Created on 09.05.2025</p> <p>@author: wf</p>"},{"location":"#warp.warp3.MeterReading","title":"<code>MeterReading</code>  <code>dataclass</code>","text":"Source code in <code>warp/warp3.py</code> <pre><code>@dataclass\nclass MeterReading:\n    kWh_in: float\n    kWh_out: float\n    time_stamp: str\n\n    @property\n    def time(self) -&gt; datetime:\n        \"\"\"Convert timestamp string to datetime object\"\"\"\n        return datetime.strptime(self.time_stamp, \"%Y-%m-%dT%H:%M:%S\")\n\n    def active_power(self, prev: \"MeterReading\") -&gt; float:\n        \"\"\"\n        calculate the active power\n        \"\"\"\n        # Time difference in hours\n        time_delta = (self.time - prev.time).total_seconds() / 3600\n        # Energy change (kWh)\n        energy_delta = (self.kWh_in - prev.kWh_in) - (self.kWh_out - prev.kWh_out)\n\n        # Power in watts\n        active_power = (energy_delta * 1000) / time_delta\n        return round(active_power)\n</code></pre>"},{"location":"#warp.warp3.MeterReading.time","title":"<code>time: datetime</code>  <code>property</code>","text":"<p>Convert timestamp string to datetime object</p>"},{"location":"#warp.warp3.MeterReading.active_power","title":"<code>active_power(prev)</code>","text":"<p>calculate the active power</p> Source code in <code>warp/warp3.py</code> <pre><code>def active_power(self, prev: \"MeterReading\") -&gt; float:\n    \"\"\"\n    calculate the active power\n    \"\"\"\n    # Time difference in hours\n    time_delta = (self.time - prev.time).total_seconds() / 3600\n    # Energy change (kWh)\n    energy_delta = (self.kWh_in - prev.kWh_in) - (self.kWh_out - prev.kWh_out)\n\n    # Power in watts\n    active_power = (energy_delta * 1000) / time_delta\n    return round(active_power)\n</code></pre>"},{"location":"#warp.warp3.PowerMeter","title":"<code>PowerMeter</code>","text":"<p>Active power meter for Warp3 Wallbox</p> Source code in <code>warp/warp3.py</code> <pre><code>class PowerMeter:\n    \"\"\"Active power meter for Warp3 Wallbox\"\"\"\n\n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        self.warp3_api = None\n\n    def setup_logging(self, debug=False):\n        level = logging.DEBUG if debug else logging.INFO\n        logging.basicConfig(\n            level=level,\n            format=\"%(asctime)s - %(levelname)s - %(message)s\",\n            handlers=[logging.StreamHandler(sys.stdout)],\n        )\n        self.logger = logging.getLogger(__name__)\n\n    def check_warp3_availability(self):\n        \"\"\"Check Warp3 version and meter config\"\"\"\n        # Check version\n        version_info = self.warp3_api.get_version()\n        if not version_info:\n            self.logger.error(\"\u274c Cannot connect to Warp3 API\")\n            return False\n\n        firmware = version_info.get(\"firmware\", \"unknown\")\n        self.logger.info(f\"\u2705 Connected to Warp3 - Firmware version: {firmware}\")\n\n        # Check meter\n        meter_id = self.wallbox_config.meter_id\n        meter_config = self.warp3_api.get_meter_config(meter_id)\n        if not meter_config:\n            self.logger.error(f\"\u274c Meter {meter_id} not available\")\n            return False\n\n        self.logger.info(f\"\u2705 Meter {meter_id} configured successfully\")\n        return True\n\n    def handle_message(self, msg):\n        \"\"\"Handle incoming MQTT message\"\"\"\n        try:\n            payload = json.loads(msg.payload.decode())\n            active_power = self.wallbox_config.calcPower(payload)\n            if active_power:\n                self.update_wallbox(active_power)\n        except json.JSONDecodeError as jde:\n            self.logger.error(f\"JSON decode error: {str(jde)}\")\n        except Exception as e:\n            self.logger.error(f\"Error handling message: {str(e)}\")\n\n    def update_wallbox(self, power_value):\n        \"\"\"Send power value to wallbox\"\"\"\n        self.logger.info(f\"Power value: {power_value}W\")\n\n        if not self.mqtt_config.dry_run:\n            self.warp3_api.update_meter(power_value, self.wallbox_config.meter_id)\n        else:\n            self.logger.info(f\"DRY RUN: would update to {power_value}W\")\n\n    def start(self):\n        \"\"\"Start the power meter\"\"\"\n        # Set up logging\n        self.setup_logging(self.args.debug)\n\n        # Initialize Warp3 API\n        self.warp3_api = Warp3Api(self.wallbox_config.wallbox_host)\n\n        # Log configuration\n        self.logger.info(\"Starting MQTT to Warp3 middleware\")\n        self.logger.info(f\"MQTT broker: {self.mqtt_config.mqtt_broker}\")\n        self.logger.info(f\"MQTT topic: {self.mqtt_config.mqtt_topic}\")\n        self.logger.info(f\"Wallbox host: {self.wallbox_config.wallbox_host}\")\n        self.logger.info(f\"Power tag: {self.wallbox_config.power_tag}\")\n        self.logger.info(f\"Meter ID: {self.wallbox_config.meter_id}\")\n\n        # Check API availability\n        if not self.check_warp3_availability():\n            self.logger.error(\"Cannot connect to Warp3 - exiting\")\n            sys.exit(1)\n\n        # Create and run client\n        client = MqttClient(self.mqtt_config, callback=self.handle_message)\n        client.run()\n\n    def maininstance(self):\n        \"\"\"Main instance setup and execution\"\"\"\n        # Parse arguments\n        self.parser = argparse.ArgumentParser(\n            description=\"MQTT to Warp3 Wallbox Middleware\"\n        )\n        self.parser.add_argument(\n            \"--config-path\", help=\"Path to YAML configuration file\"\n        )\n        MqttConfig.addArgs(self.parser)\n        WallboxConfig.addArgs(self.parser)\n        self.parser.add_argument(\n            \"--debug\", action=\"store_true\", help=\"Enable debug logging\"\n        )\n        self.args = self.parser.parse_args()\n\n        # Create configurations\n        if self.args.config_path:\n            self.logger = logging.getLogger(__name__)\n            self.logger.info(f\"Loading configuration from {self.args.config_path}\")\n            try:\n                self.mqtt_config = MqttConfig.ofYaml(self.args.config_path)\n                self.wallbox_config = WallboxConfig.ofYaml(self.args.config_path)\n            except Exception as e:\n                self.logger.error(f\"Failed to load configuration from YAML: {e}\")\n                sys.exit(1)\n        else:\n            self.mqtt_config = MqttConfig.ofArgs(self.args)\n            self.wallbox_config = WallboxConfig.ofArgs(self.args)\n\n        self.start()\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.check_warp3_availability","title":"<code>check_warp3_availability()</code>","text":"<p>Check Warp3 version and meter config</p> Source code in <code>warp/warp3.py</code> <pre><code>def check_warp3_availability(self):\n    \"\"\"Check Warp3 version and meter config\"\"\"\n    # Check version\n    version_info = self.warp3_api.get_version()\n    if not version_info:\n        self.logger.error(\"\u274c Cannot connect to Warp3 API\")\n        return False\n\n    firmware = version_info.get(\"firmware\", \"unknown\")\n    self.logger.info(f\"\u2705 Connected to Warp3 - Firmware version: {firmware}\")\n\n    # Check meter\n    meter_id = self.wallbox_config.meter_id\n    meter_config = self.warp3_api.get_meter_config(meter_id)\n    if not meter_config:\n        self.logger.error(f\"\u274c Meter {meter_id} not available\")\n        return False\n\n    self.logger.info(f\"\u2705 Meter {meter_id} configured successfully\")\n    return True\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.handle_message","title":"<code>handle_message(msg)</code>","text":"<p>Handle incoming MQTT message</p> Source code in <code>warp/warp3.py</code> <pre><code>def handle_message(self, msg):\n    \"\"\"Handle incoming MQTT message\"\"\"\n    try:\n        payload = json.loads(msg.payload.decode())\n        active_power = self.wallbox_config.calcPower(payload)\n        if active_power:\n            self.update_wallbox(active_power)\n    except json.JSONDecodeError as jde:\n        self.logger.error(f\"JSON decode error: {str(jde)}\")\n    except Exception as e:\n        self.logger.error(f\"Error handling message: {str(e)}\")\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.maininstance","title":"<code>maininstance()</code>","text":"<p>Main instance setup and execution</p> Source code in <code>warp/warp3.py</code> <pre><code>def maininstance(self):\n    \"\"\"Main instance setup and execution\"\"\"\n    # Parse arguments\n    self.parser = argparse.ArgumentParser(\n        description=\"MQTT to Warp3 Wallbox Middleware\"\n    )\n    self.parser.add_argument(\n        \"--config-path\", help=\"Path to YAML configuration file\"\n    )\n    MqttConfig.addArgs(self.parser)\n    WallboxConfig.addArgs(self.parser)\n    self.parser.add_argument(\n        \"--debug\", action=\"store_true\", help=\"Enable debug logging\"\n    )\n    self.args = self.parser.parse_args()\n\n    # Create configurations\n    if self.args.config_path:\n        self.logger = logging.getLogger(__name__)\n        self.logger.info(f\"Loading configuration from {self.args.config_path}\")\n        try:\n            self.mqtt_config = MqttConfig.ofYaml(self.args.config_path)\n            self.wallbox_config = WallboxConfig.ofYaml(self.args.config_path)\n        except Exception as e:\n            self.logger.error(f\"Failed to load configuration from YAML: {e}\")\n            sys.exit(1)\n    else:\n        self.mqtt_config = MqttConfig.ofArgs(self.args)\n        self.wallbox_config = WallboxConfig.ofArgs(self.args)\n\n    self.start()\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.start","title":"<code>start()</code>","text":"<p>Start the power meter</p> Source code in <code>warp/warp3.py</code> <pre><code>def start(self):\n    \"\"\"Start the power meter\"\"\"\n    # Set up logging\n    self.setup_logging(self.args.debug)\n\n    # Initialize Warp3 API\n    self.warp3_api = Warp3Api(self.wallbox_config.wallbox_host)\n\n    # Log configuration\n    self.logger.info(\"Starting MQTT to Warp3 middleware\")\n    self.logger.info(f\"MQTT broker: {self.mqtt_config.mqtt_broker}\")\n    self.logger.info(f\"MQTT topic: {self.mqtt_config.mqtt_topic}\")\n    self.logger.info(f\"Wallbox host: {self.wallbox_config.wallbox_host}\")\n    self.logger.info(f\"Power tag: {self.wallbox_config.power_tag}\")\n    self.logger.info(f\"Meter ID: {self.wallbox_config.meter_id}\")\n\n    # Check API availability\n    if not self.check_warp3_availability():\n        self.logger.error(\"Cannot connect to Warp3 - exiting\")\n        sys.exit(1)\n\n    # Create and run client\n    client = MqttClient(self.mqtt_config, callback=self.handle_message)\n    client.run()\n</code></pre>"},{"location":"#warp.warp3.PowerMeter.update_wallbox","title":"<code>update_wallbox(power_value)</code>","text":"<p>Send power value to wallbox</p> Source code in <code>warp/warp3.py</code> <pre><code>def update_wallbox(self, power_value):\n    \"\"\"Send power value to wallbox\"\"\"\n    self.logger.info(f\"Power value: {power_value}W\")\n\n    if not self.mqtt_config.dry_run:\n        self.warp3_api.update_meter(power_value, self.wallbox_config.meter_id)\n    else:\n        self.logger.info(f\"DRY RUN: would update to {power_value}W\")\n</code></pre>"},{"location":"#warp.warp3.WallboxConfig","title":"<code>WallboxConfig</code>","text":"<p>Configuration for the Warp3 wallbox</p> Source code in <code>warp/warp3.py</code> <pre><code>@lod_storable\nclass WallboxConfig:\n    \"\"\"Configuration for the Warp3 wallbox\"\"\"\n\n    wallbox_host: str = \"http://warp3.mydomain\"\n    # example Tasmota reading\n    power_tag: str = \"eHZ\"  # json tag for the payload content\n    in_field: str = \"E_in\"  # field for energy input\n    out_field: str = \"E_out\"  # field for energy output\n    time_field: str = \"Time\"  # field for timestamp\n    meter_id: int = 2  # id of the meter configured\n\n    @classmethod\n    def ofArgs(cls, args: Namespace = None):\n        \"\"\"\n        Create a configuration from command line arguments.\n\n        Args:\n            args: Optional list of command line arguments. If None, sys.argv is used.\n\n        Returns:\n            WallboxConfig: Configuration object\n        \"\"\"\n        if args is None:\n            config = cls()\n        else:\n            config = cls(\n                wallbox_host=args.wallbox_host,\n                power_tag=args.power_tag,  # Added this\n                in_field=args.in_field,  # Added new field\n                out_field=args.out_field,  # Added new field\n                time_field=args.time_field,  # Added new field\n                meter_id=args.meter_id,  # Added this\n            )\n        return config\n\n    @classmethod\n    def addArgs(cls, parser):\n        \"\"\"\n        Add command line arguments for WallboxConfig to the given parser.\n\n        Args:\n            parser: The argument parser to add arguments to\n        \"\"\"\n        parser.add_argument(\n            \"--wallbox-host\", help=\"Wallbox host URL\", default=cls.wallbox_host\n        )\n        parser.add_argument(\n            \"--power-tag\",\n            help=\"Tag in MQTT data containing power information\",\n            default=cls.power_tag,\n        )\n        parser.add_argument(\n            \"--in-field\",\n            help=\"Field name in MQTT data containing energy input\",\n            default=cls.in_field,\n        )\n        parser.add_argument(\n            \"--out-field\",\n            help=\"Field name in MQTT data containing energy output\",\n            default=cls.out_field,\n        )\n        parser.add_argument(\n            \"--time-field\",\n            help=\"Field name in MQTT data containing timestamp\",\n            default=cls.time_field,\n        )\n        parser.add_argument(\n            \"--meter-id\", type=int, help=\"Meter ID to use\", default=cls.meter_id\n        )\n\n    @classmethod\n    def ofYaml(cls, yaml_path):\n        config = cls.load_from_yaml_file(yaml_path)\n        return config\n\n    def calcPower(self, payload) -&gt; float:\n        \"\"\"\n        Calculate power from payload using MeterReading class.\n\n        Args:\n            payload: The decoded JSON payload from MQTT message\n\n        Returns:\n            float: Calculated power in watts\n        \"\"\"\n        # Get the data from the payload\n        data = payload.get(self.power_tag, {})\n\n        # Extract values\n        e_in = data.get(self.in_field)\n        e_out = data.get(self.out_field)\n        timestamp_str = payload.get(self.time_field)\n\n        # Create current reading\n        current = MeterReading(kWh_in=e_in, kWh_out=e_out, time_stamp=timestamp_str)\n\n        # If we don't have a previous reading, store this one and return fallback power\n        if not hasattr(self, \"_last_reading\"):\n            power = None\n        else:\n            power = current.active_power(self._last_reading)\n        # Update stored reading\n        self._last_reading = current\n        return power\n</code></pre>"},{"location":"#warp.warp3.WallboxConfig.addArgs","title":"<code>addArgs(parser)</code>  <code>classmethod</code>","text":"<p>Add command line arguments for WallboxConfig to the given parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <p>The argument parser to add arguments to</p> required Source code in <code>warp/warp3.py</code> <pre><code>@classmethod\ndef addArgs(cls, parser):\n    \"\"\"\n    Add command line arguments for WallboxConfig to the given parser.\n\n    Args:\n        parser: The argument parser to add arguments to\n    \"\"\"\n    parser.add_argument(\n        \"--wallbox-host\", help=\"Wallbox host URL\", default=cls.wallbox_host\n    )\n    parser.add_argument(\n        \"--power-tag\",\n        help=\"Tag in MQTT data containing power information\",\n        default=cls.power_tag,\n    )\n    parser.add_argument(\n        \"--in-field\",\n        help=\"Field name in MQTT data containing energy input\",\n        default=cls.in_field,\n    )\n    parser.add_argument(\n        \"--out-field\",\n        help=\"Field name in MQTT data containing energy output\",\n        default=cls.out_field,\n    )\n    parser.add_argument(\n        \"--time-field\",\n        help=\"Field name in MQTT data containing timestamp\",\n        default=cls.time_field,\n    )\n    parser.add_argument(\n        \"--meter-id\", type=int, help=\"Meter ID to use\", default=cls.meter_id\n    )\n</code></pre>"},{"location":"#warp.warp3.WallboxConfig.calcPower","title":"<code>calcPower(payload)</code>","text":"<p>Calculate power from payload using MeterReading class.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <p>The decoded JSON payload from MQTT message</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Calculated power in watts</p> Source code in <code>warp/warp3.py</code> <pre><code>def calcPower(self, payload) -&gt; float:\n    \"\"\"\n    Calculate power from payload using MeterReading class.\n\n    Args:\n        payload: The decoded JSON payload from MQTT message\n\n    Returns:\n        float: Calculated power in watts\n    \"\"\"\n    # Get the data from the payload\n    data = payload.get(self.power_tag, {})\n\n    # Extract values\n    e_in = data.get(self.in_field)\n    e_out = data.get(self.out_field)\n    timestamp_str = payload.get(self.time_field)\n\n    # Create current reading\n    current = MeterReading(kWh_in=e_in, kWh_out=e_out, time_stamp=timestamp_str)\n\n    # If we don't have a previous reading, store this one and return fallback power\n    if not hasattr(self, \"_last_reading\"):\n        power = None\n    else:\n        power = current.active_power(self._last_reading)\n    # Update stored reading\n    self._last_reading = current\n    return power\n</code></pre>"},{"location":"#warp.warp3.WallboxConfig.ofArgs","title":"<code>ofArgs(args=None)</code>  <code>classmethod</code>","text":"<p>Create a configuration from command line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Optional list of command line arguments. If None, sys.argv is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>WallboxConfig</code> <p>Configuration object</p> Source code in <code>warp/warp3.py</code> <pre><code>@classmethod\ndef ofArgs(cls, args: Namespace = None):\n    \"\"\"\n    Create a configuration from command line arguments.\n\n    Args:\n        args: Optional list of command line arguments. If None, sys.argv is used.\n\n    Returns:\n        WallboxConfig: Configuration object\n    \"\"\"\n    if args is None:\n        config = cls()\n    else:\n        config = cls(\n            wallbox_host=args.wallbox_host,\n            power_tag=args.power_tag,  # Added this\n            in_field=args.in_field,  # Added new field\n            out_field=args.out_field,  # Added new field\n            time_field=args.time_field,  # Added new field\n            meter_id=args.meter_id,  # Added this\n        )\n    return config\n</code></pre>"},{"location":"#warp.warp3.main","title":"<code>main()</code>","text":"<p>Main entry point</p> Source code in <code>warp/warp3.py</code> <pre><code>def main():\n    \"\"\"Main entry point\"\"\"\n    pm = PowerMeter()\n    pm.maininstance()\n</code></pre>"},{"location":"#warp.warp3_api","title":"<code>warp3_api</code>","text":"<p>Created on 2025-05-09</p> <p>@author: wf</p>"},{"location":"#warp.warp3_api.Warp3Api","title":"<code>Warp3Api</code>","text":"<p>API client for TinkerForge/Warp3 Wallbox</p> Source code in <code>warp/warp3_api.py</code> <pre><code>class Warp3Api:\n    \"\"\"API client for TinkerForge/Warp3 Wallbox\"\"\"\n\n    def __init__(self, host):\n        \"\"\"Initialize with wallbox host\"\"\"\n        self.host = host.rstrip(\"/\")\n        self.logger = logging.getLogger(__name__)\n\n    def api_get(self, cmd):\n        \"\"\"\n        Call the wallbox API with the given command and filter the JSON result\n\n        Args:\n            cmd: API command\n\n\n        Returns:\n            API response\n        \"\"\"\n        api_response = None\n        try:\n            http_response = requests.get(f\"{self.host}/{cmd}\")\n            http_response.raise_for_status()\n            api_response = http_response.json()\n        except Exception as e:\n            self.logger.error(f\"API GET error: {e}\")\n        return api_response\n\n    def get_version(self):\n        \"\"\"Get wallbox firmware version\"\"\"\n        version_info = self.api_get(\"info/version\")\n        return version_info\n\n    def get_meter_config(self, meter_id=1):\n        \"\"\"Get meter configuration\"\"\"\n        meter_config = self.api_get(f\"meters/{meter_id}/config\")\n        return meter_config\n\n    def update_meter(self, value, meter_id=1):\n        \"\"\"\n        Update meter value\n\n        Args:\n            value: Power value in Watts\n            meter_id: Meter ID (default 1)\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        update_success = False\n        try:\n            url = f\"{self.host}/meters/{meter_id}/update\"\n            http_response = requests.post(url, data=f\"[{value}]\")\n            if http_response.status_code == 200 and not http_response.text:\n                self.logger.info(f\"\u2705 {value} Watt set\")\n                update_success = True\n            else:\n                self.logger.error(f\"\u274c Failed to update: {http_response.text}\")\n        except Exception as e:\n            self.logger.error(f\"Error updating meter: {e}\")\n        return update_success\n</code></pre>"},{"location":"#warp.warp3_api.Warp3Api.__init__","title":"<code>__init__(host)</code>","text":"<p>Initialize with wallbox host</p> Source code in <code>warp/warp3_api.py</code> <pre><code>def __init__(self, host):\n    \"\"\"Initialize with wallbox host\"\"\"\n    self.host = host.rstrip(\"/\")\n    self.logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"#warp.warp3_api.Warp3Api.api_get","title":"<code>api_get(cmd)</code>","text":"<p>Call the wallbox API with the given command and filter the JSON result</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <p>API command</p> required <p>Returns:</p> Type Description <p>API response</p> Source code in <code>warp/warp3_api.py</code> <pre><code>def api_get(self, cmd):\n    \"\"\"\n    Call the wallbox API with the given command and filter the JSON result\n\n    Args:\n        cmd: API command\n\n\n    Returns:\n        API response\n    \"\"\"\n    api_response = None\n    try:\n        http_response = requests.get(f\"{self.host}/{cmd}\")\n        http_response.raise_for_status()\n        api_response = http_response.json()\n    except Exception as e:\n        self.logger.error(f\"API GET error: {e}\")\n    return api_response\n</code></pre>"},{"location":"#warp.warp3_api.Warp3Api.get_meter_config","title":"<code>get_meter_config(meter_id=1)</code>","text":"<p>Get meter configuration</p> Source code in <code>warp/warp3_api.py</code> <pre><code>def get_meter_config(self, meter_id=1):\n    \"\"\"Get meter configuration\"\"\"\n    meter_config = self.api_get(f\"meters/{meter_id}/config\")\n    return meter_config\n</code></pre>"},{"location":"#warp.warp3_api.Warp3Api.get_version","title":"<code>get_version()</code>","text":"<p>Get wallbox firmware version</p> Source code in <code>warp/warp3_api.py</code> <pre><code>def get_version(self):\n    \"\"\"Get wallbox firmware version\"\"\"\n    version_info = self.api_get(\"info/version\")\n    return version_info\n</code></pre>"},{"location":"#warp.warp3_api.Warp3Api.update_meter","title":"<code>update_meter(value, meter_id=1)</code>","text":"<p>Update meter value</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>Power value in Watts</p> required <code>meter_id</code> <p>Meter ID (default 1)</p> <code>1</code> <p>Returns:</p> Type Description <p>True if successful, False otherwise</p> Source code in <code>warp/warp3_api.py</code> <pre><code>def update_meter(self, value, meter_id=1):\n    \"\"\"\n    Update meter value\n\n    Args:\n        value: Power value in Watts\n        meter_id: Meter ID (default 1)\n\n    Returns:\n        True if successful, False otherwise\n    \"\"\"\n    update_success = False\n    try:\n        url = f\"{self.host}/meters/{meter_id}/update\"\n        http_response = requests.post(url, data=f\"[{value}]\")\n        if http_response.status_code == 200 and not http_response.text:\n            self.logger.info(f\"\u2705 {value} Watt set\")\n            update_success = True\n        else:\n            self.logger.error(f\"\u274c Failed to update: {http_response.text}\")\n    except Exception as e:\n        self.logger.error(f\"Error updating meter: {e}\")\n    return update_success\n</code></pre>"}]}